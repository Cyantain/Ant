{
  "nl_statement": "Consider nine points in space, no four of which are coplanar. Each pair of points is joined by an edge (that is, a line segment) and each edge is either colored blue or red or left uncolored. Find the smallest value of $n$ such that whenever exactly n edges are colored, the set of colored edges necessarily contains a triangle all of whose edges have the same color.",
  "nl_proof": "We show that for $n = 32$ we can find a coloring without a monochrome triangle. Take two squares $R_1R_2R_3R_4$ and $B_1B_2B_3B_4$. Leave the diagonals of each square uncolored, color the remaining edges of $R$ red and the remaining edges of $B$ blue. Color blue all the edges from the ninth point $X$ to the red square, and red all the edges from $X$ to the blue square. Color $R_iB_j$ red if $i$ and $j$ have the same parity and blue otherwise. Clearly $X$ is not the vertex of a monochrome square, because if $XY$ and $XZ$ are the same color then, $YZ$ is either uncolored or the opposite color. There is no triangle within the red square or the blue square, and hence no monochrome triangle. It remains to consider triangles of the form $R_iR_jB_k$ and $B_iB_jR_k.$ But if $i$ and $j$ have the same parity, then $R_iR_j$ is uncolored (and similarly $B_iB_j$ ), whereas if they have opposite parity, then $R_iB_k$ and $R_jB_k$ have opposite colors (and similarly $B_iR_k$ and $B_jR_k$ ). It remains to show that for $n = 33$ we can always find a monochrome triangle. There are three uncolored edges. Take a point on each of the uncolored edges. The edges between the remaining $6$ points must all be colored. Take one of these, $X.$ At least $3$ of the $5$ edges to $X$, say $XA$, $XB$, $XC$ must be the same color (say red). If $AB$ is also red, then $XAB$ is monochrome. Similarly, for $BC$ and $CA.$ But if $AB$, $BC$ and $CA$ are all blue, then $ABC$ is monochrome.",
  "lean": "import Mathlib\\n\\n/-\\nConsider nine points in space, no four of which are coplanar. Each pair of points is joined by an edge (that is, a line segment) and each edge is either colored blue or red or left uncolored. Find the smallest value of n such that whenever exactly n edges are colored, the set of colored edges necessarily contains a triangle all of whose edges have the same color.\\n-/\\n\\nsection port\\n\\n-- Helper lemmas ported from or similar to mathlib for Finset min/max properties.\\n\\n/-- The minimum of a nonempty finset $s$ is $a$ iff $a$ is in $s$ and is a lower bound for $s$. -/\\nlemma Finset.min'_eq_iff {α : Type*} [LinearOrder α] (s : Finset α) (H : s.Nonempty)\\n    (a : α) : s.min' H = a ↔ a ∈ s ∧ ∀ (b : α), b ∈ s → a ≤ b :=\\n  ⟨(· ▸ ⟨min'_mem _ _, min'_le _⟩),\\n    fun h ↦ le_antisymm (min'_le _ _ h.1) (le_min' _ _ _ h.2)⟩\\n\\n/-- The maximum of a nonempty finset $s$ is $a$ iff $a$ is in $s$ and is an upper bound for $s$. -/\\nlemma Finset.max'_eq_iff {α : Type*} [LinearOrder α] (s : Finset α) (H : s.Nonempty)\\n    (a : α) : s.max' H = a ↔ a ∈ s ∧ ∀ (b : α), b ∈ s → b ≤ a :=\\n  ⟨(· ▸ ⟨max'_mem _ _, le_max' _⟩),\\n    fun h ↦ le_antisymm (max'_le _ _ _ h.2) (le_max' _ _ h.1)⟩\\n\\nend port\\n\\nsection setup\\n\\n/-- Represents a segment (edge) between two points, identified by indices from \"Fin 9\".\\n    The $ini < ter$ condition ensures a canonical representation for each edge. -/\\n@[ext]\\nclass Seg where\\n  ini : Fin 9\\n  ter : Fin 9\\n  nodup : ini < ter := by decide\\n\\n/-- A type alias for a finset of 2 points, representing an edge. -/\\nlocal notation3 \"Fseg\" => Finset.powersetCard 2 (Finset.range 9)\\n\\n/-- Converts a \"Seg\" to its \"Fseg\" representation (a 2-element \"finset\"). -/\\nabbrev Seg.toFseg : Seg → Fseg := by\\n  intro x\\n  use {x.ini.1, x.ter.1}\\n  refine Finset.mem_powersetCard.2 ?_\\n  constructor\\n  · -- Proof that elements are in \"range 9\".\\n    intro y hy\\n    rw [Finset.mem_insert, Finset.mem_singleton] at hy\\n    casesm* _ ∨ _\\n    · exact hy ▸ Finset.mem_range.2 Seg.ini.isLt\\n    · exact hy ▸ Finset.mem_range.2 Seg.ter.isLt\\n  · -- Proof that card is 2.\\n    exact Finset.card_pair <| Nat.ne_of_lt Seg.nodup\\n\\n/-- A 2-element \"finset\" is nonempty. -/\\nlemma nonem {y : Fseg} : y.1.Nonempty :=\\n  Finset.card_pos.1\\n    <| Eq.mpr (congrArg _\\n      (Finset.mem_powersetCard.1 y.2).2) Nat.zero_lt_two\\n\\n/-- The smaller point index in an \"Fseg\". -/\\ndef Fseg_min (y : Fseg) := y.1.min' nonem\\n/-- The larger point index in an \"Fseg\". -/\\ndef Fseg_max (y : Fseg) := y.1.max' nonem\\n\\n/-- The smaller point index lies in \"Fseg\". -/\\nlemma Fseg_min_mem (y : Fseg) : Fseg_min y ∈ y.1 :=\\n  Finset.min'_mem y.1 nonem\\n/-- The larger point index lies in \"Fseg\". -/\\nlemma Fseg_max_mem (y : Fseg) : Fseg_max y ∈ y.1 :=\\n  Finset.max'_mem y.1 nonem\\n/-- The smaller point index is strictly smaller than the larger point index. -/\\nlemma Fseg_min_lt_max (y : Fseg) : Fseg_min y < Fseg_max y :=\\n  have := Finset.mem_powersetCard.1 y.2\\n  Finset.min'_lt_max'_of_card y.1 (by omega)\\n\\n/-- A 2-element \"finset\" is determined by its min and max elements. -/\\nlemma Fseg_eq (y : Fseg) : y.1 = {y.1.min' nonem, y.1.max' nonem} := by\\n  have : {Fseg_min y, Fseg_max y} ⊆ y.1 :=\\n    Finset.insert_subset (Fseg_min_mem y) <|\\n      Finset.singleton_subset_iff.mpr (Fseg_max_mem y)\\n  refine Finset.eq_of_superset_of_card_ge this ?_\\n  show _ ≤ Finset.card {Fseg_min y, Fseg_max y}\\n  rw [Finset.card_pair <| Nat.ne_of_lt (Fseg_min_lt_max y),\\n    (Finset.mem_powersetCard.1 y.2).2]\\n\\n/-- Converts an \"Fseg\" (a 2-element \"finset\") back to a \"Seg\". -/\\nabbrev Seg.ofFseg : Fseg → Seg := fun y ↦\\n  ⟨⟨Fseg_min y, List.mem_range.mp <|\\n    (Finset.mem_powersetCard.1 y.2).1 (Fseg_min_mem y)⟩,\\n   ⟨Fseg_max y, List.mem_range.mp <|\\n    (Finset.mem_powersetCard.1 y.2).1 (Fseg_max_mem y)⟩, Fseg_min_lt_max y⟩\\n\\n/-- \"ofFseg\" is the left inverse of \"toFseg\". -/\\nlemma left_inv {x : Seg} : Seg.ofFseg x.toFseg = x := by\\n  simp [Seg.toFseg, Seg.ofFseg]\\n  ext\\n  · simp [Fseg_min, Finset.min'_eq_iff]\\n    exact Fin.le_of_lt x.nodup\\n  · simp [Fseg_max, Finset.max'_eq_iff]\\n    exact Fin.le_of_lt x.nodup\\n\\n/-- \"toFseg\" is the right inverse of \"ofFseg\". -/\\nlemma right_inv {y : Fseg} : (Seg.ofFseg y).toFseg = y := by\\n  simp [Seg.toFseg, Seg.ofFseg]\\n  apply Subtype.val_inj.1\\n  nth_rw 2 [Fseg_eq]\\n  rfl\\n\\n/-- An equivalence between the canonical \"Seg\" representation and the \"Fseg\" representation. -/\\ndef Seg_FS : Seg ≃ Fseg where\\n  toFun := Seg.toFseg\\n  invFun := Seg.ofFseg\\n  left_inv := fun _ ↦ left_inv\\n  right_inv := fun _ ↦ right_inv\\n\\n/-- Establishes \"Seg\" as a finite type. -/\\ninstance : Fintype Seg :=\\n  Fintype.ofEquiv Fseg Seg_FS.symm\\n\\n/-- A coloring scheme: maps each edge to an optional color (red/blue, i.e., \"Fin 2\").\\n    \"none\" means the edge is uncolored. -/\\nnotation \"scheme\" => Seg → Option (Fin 2)\\n\\n/-- Represents a triangle, defined by three ordered points $a < b < c$. -/\\nclass Tri where\\n  a : Fin 9\\n  b : Fin 9\\n  c : Fin 9\\n  nodup : a < b ∧ b < c := by decide\\n\\n/-- The three segments (edges) forming a triangle. -/\\nabbrev Tri.toSegs (y : Tri) : List Seg :=\\n  [⟨y.a, y.b, y.nodup.1⟩, ⟨y.b, y.c, y.nodup.2⟩,\\n    ⟨y.a, y.c, y.nodup.1.trans y.nodup.2⟩]\\n\\n/-- A triangle is \"not monochromatic\" if at least one edge is uncolored,\\n    or if the colored edges have more than one distinct color. -/\\nabbrev Tri.notMono (y : Tri) (f : scheme) : Prop :=\\n  have list := (Tri.toSegs y).map f\\n  list.contains (none (α := Fin 2)) ∨ 1 < list.dedup.length\\n\\n/-- The set of uncolored (\"void\") edges in a scheme. -/\\nabbrev void (f : scheme) : Finset Seg :=\\n  (Finset.univ (α := Seg)).filter (f · = none)\\n\\n/-- The set of colored edges in a scheme. -/\\nabbrev colored (f : scheme) : Finset Seg :=\\n  (Finset.univ (α := Seg)).filter (f · ≠ none)\\n\\n/-- predicate that a scheme has no monochromatic triangles. -/\\nabbrev Scheme.noMono (f : scheme) : Prop :=\\n  ∀ y : Tri, y.notMono f\\n\\nend setup\\n\\n/-- The total number of segments (edges) is $\\binom{9}{2} = 36$. -/\\nlemma Seg.card : Nat.card Seg = 36 := by\\n  rw [Nat.card_congr Seg_FS, Nat.card_eq_finsetCard,\\n    Finset.card_powersetCard]\\n  decide\\n\\n/-- A specific coloring scheme with 32 colored edges, used as a counterexample. -/\\ndef n_32 : scheme := fun ⟨ini, ter, _⟩ ↦\\n  match ini with\\n  | 0 => match ter with\\n    | 1 => some 0 | 2 => none   | 3 => some 0 | 4 => some 0\\n    | 5 => some 1 | 6 => some 0 | 7 => some 1 | 8 => some 1\\n  | 1 => match ter with\\n    | 2 => some 0 | 3 => none   | 4 => some 1 | 5 => some 0\\n    | 6 => some 1 | 7 => some 0 | 8 => some 1\\n  | 2 => match ter with\\n    | 3 => some 0 | 4 => some 0 | 5 => some 1 | 6 => some 0\\n    | 7 => some 1 | 8 => some 1\\n  | 3 => match ter with\\n    | 4 => some 1 | 5 => some 0 | 6 => some 1 | 7 => some 0\\n    | 8 => some 1\\n  | 4 => match ter with\\n    | 5 => some 1 | 6 => none   | 7 => some 1 | 8 => some 0\\n  | 5 => match ter with\\n    | 6 => some 1 | 7 => none   | 8 => some 0\\n  | 6 => match ter with\\n    | 7 => some 1 | 8 => some 0\\n  | 7 => match ter with | 8 => some 0\\n  | 8 => by omega\\n\\n/-- Asserts that \"Seg\" has decidable equality. -/\\ninstance : DecidableEq Seg := by\\n  intro a b\\n  rw [Seg.ext_iff]\\n  exact instDecidableAnd\\n\\n/-- The sum of uncolored and colored edges is the total number of edges (36). -/\\nlemma void_add_colored (f : scheme) :\\n    (void f).card + (colored f).card = 36 := by\\n  rw [← Seg.card, Nat.card_eq_fintype_card, ← Finset.card_univ,\\n    ← Finset.card_union_of_disjoint (Finset.disjoint_filter_filter_neg _ _ _)]\\n  congr\\n  exact Finset.filter_union_filter_neg_eq _ _\\n\\n/-- Proof that the \"n_32\" scheme has no monochromatic triangles. -/\\nlemma n_32_noMono : Scheme.noMono n_32 := by\\n  intro ⟨a, b, c, nodup⟩\\n  -- Proof by exhaustive case check. This step is slow, please wait patiently.\\n  fin_cases a <;> fin_cases b <;> fin_cases c\\n  all_goals first | omega | decide +revert\\n\\n/-- If a triangle is monochromatic, all its edges are colored with the same color $i$. -/\\nlemma Tri.not_notMono (y : Tri) (f : scheme) (hf : ¬ y.notMono f) :\\n    ∃ i, (Tri.toSegs y).map f = [i, i, i] ∧ i ≠ none := by\\n  unfold Tri.notMono at hf\\n  set list := List.map f y.toSegs with def_2\\n  -- hf now means no \"none\" and \"dedup.length\" $\\leq 1$.\\n  simp at hf\\n  obtain ⟨hf1 : ¬ (none ∈ list), hf2⟩ := hf\\n  rw [List.mem_map] at hf1\\n  push_neg at hf1\\n  -- Since the list is non-empty and has no \"none\", \"dedup.length\" must be 1.\\n  obtain (hf | hf) : list.dedup.length = 0 ∨ list.dedup.length = 1 := by omega\\n  · replace hf := (List.dedup_eq_nil _).1 <| List.eq_nil_of_length_eq_zero hf\\n    rw [def_2, List.map_eq_nil_iff] at hf\\n    tauto\\n  · -- \"dedup\" has a single element $a$.\\n    obtain ⟨a, ha⟩ := List.length_eq_one.1 hf\\n    -- This means all elements of the original list are $a$.\\n    have : ∀ x ∈ list, x = a := by\\n      intro x hx\\n      rw [← List.mem_dedup, ha] at hx\\n      simpa using hx\\n    use a\\n    constructor\\n    · simpa [def_2] using this\\n    · -- $a$ cannot be none.\\n      intro ha_none\\n      rw [def_2] at this\\n      absurd hf1\\n      push_neg\\n      use y.toSegs[0]\\n      constructor\\n      · tauto\\n      · specialize this (f y.toSegs[0]) (List.mem_of_mem_head? rfl)\\n        exact ha_none ▸ this\\n\\n/-- For any $y \\leq 32$, there exists a coloring with $y$ edges that has no monochromatic triangle.\\n    This shows that the answer $n$ must be greater than 32. -/\\nlemma IMO1992Q3_n_32_case_1 {y : ℕ} (ylt : y ≤ 32) : ¬ ∀ (f : scheme),\\n    (colored f).card = y → ¬Scheme.noMono f := by\\n  -- We construct a counterexample by taking a subset of $y$ edges from the \"n_32\" scheme.\\n  set new := ((colored n_32).toList.splitAt y).1.toFinset with new_def\\n  push_neg\\n  use fun x ↦ if x ∈ new then n_32 x else none\\n  have foo : (List.splitAt y (colored n_32).toList).1 ⊆ (colored n_32).toList := by\\n    simp only [List.splitAt_eq]\\n    exact List.take_subset _ _\\n  have nodup : (List.splitAt y (colored n_32).toList).1.Nodup := by\\n    refine (List.Sublist.nodup (l₂ := (colored n_32).toList)) ?_ ?_\\n    · simp only [List.splitAt_eq]\\n      exact List.take_sublist _ _\\n    · exact Finset.nodup_toList (colored n_32)\\n  have mem_new {x} : x ∈ new → ¬n_32 x = none := by\\n    intro h\\n    rw [new_def, List.mem_toFinset] at h\\n    simpa only [Finset.mem_toList, Finset.mem_filter,\\n      Finset.mem_univ, ne_eq, true_and] using foo h\\n  constructor\\n  · -- The number of colored edges is exactly $y$.\\n    simp [colored]\\n    have {x} : (x ∈ new ∧ ¬n_32 x = none) ↔ x ∈ new := by\\n      constructor\\n      · tauto\\n      · exact fun h ↦ And.symm ⟨mem_new h, h⟩\\n    conv =>\\n      enter [1, 1, 1, x]\\n      rw [this]\\n    rw [Finset.filter_univ_mem, new_def, List.toFinset_card_of_nodup nodup,\\n      List.splitAt_eq, List.length_take, Finset.length_toList, inf_eq_left]\\n    exact ylt\\n  · -- This new scheme has no monochromatic triangles.\\n    intro t\\n    have h_n32 := n_32_noMono t\\n    -- Assume there is a monochromatic triangle $t$.\\n    by_contra h\\n    obtain ⟨a, ha⟩ := Tri.not_notMono t _ h\\n    unfold Tri.notMono at h_n32\\n    set list' := List.map n_32 t.toSegs with def_2\\n    dsimp at h_n32\\n    -- If $t$ is monochromatic in our new scheme, all its edges must be in \"new\".\\n    have {x} : x ∈ t.toSegs → x ∈ new := by\\n      intro hx\\n      by_contra!\\n      have : none ∈ [a, a, a] := by\\n        rw [← ha.1, List.mem_map]\\n        use x, hx\\n        simp [this]\\n      simp only [List.mem_cons, List.not_mem_nil, or_false, or_self] at this\\n      exact ha.2 this.symm\\n    -- This implies $t$ would also be monochromatic in the original \"n_32\" scheme.\\n    replace this : [a, a, a] = list' := by\\n      rw [def_2, ← ha.1]\\n      refine List.map_inj_left.mpr ?_\\n      intro a ha\\n      simp [this ha]\\n    -- This contradicts \"n_32_noMono\".\\n    absurd h_n32\\n    push_neg\\n    constructor\\n    · rw [← this]\\n      simp only [List.contains_eq_mem, List.mem_cons, List.not_mem_nil, or_false, or_self, ne_eq,\\n        decide_eq_true_eq]\\n      exact ha.2.symm\\n    · rw [← this]\\n      simp only [List.mem_cons, List.not_mem_nil, or_false, or_self, List.dedup_cons_of_mem,\\n        not_false_eq_true, List.dedup_cons_of_not_mem, List.dedup_nil, List.length_cons,\\n        List.length_nil, zero_add, le_refl]\\n\\n/-- If exactly 3 edges are uncolored, there exists a set of 6 points (a $K6$)\\n    where all edges are colored. -/\\nlemma select {f : scheme} (hf : (void f).card = 3) :\\n    ∃ xs : Finset (Fin 9), xs.card = 6 ∧\\n      ∀ x ∈ xs, ∀ y ∈ xs, (hxy : x < y) → f ⟨x, y, hxy⟩ ≠ none := by\\n  -- Get the three uncolored edges.\\n  obtain ⟨s1, s2, s3, h⟩ := Finset.card_eq_three.1 hf\\n  -- Consider the set of points that are NOT the starting point of an uncolored edge.\\n  set base : Finset (Fin 9) := Finset.univ \\ {s1.1, s2.1, s3.1} with def_base\\n  -- This set has at least $9 - 3 = 6$ points.\\n  have base_card : 6 ≤ base.card := by\\n    rw [Finset.card_univ_diff]\\n    show 6 ≤ 9 - _\\n    have : Finset.card {s1.1, s2.1, s3.1} ≤ 3 := Finset.card_le_three\\n    omega\\n  -- Take a subset \"xs\" of size 6 from \"base\".\\n  obtain ⟨xs, hxs⟩ : ∃ xs : Finset (Fin 9), xs ⊆ base ∧ xs.card = 6 :=\\n    Finset.le_card_iff_exists_subset_card.mp base_card\\n  use xs, hxs.2\\n  -- Any edge between two points in \"xs\" must be colored.\\n  intro x hx y hy hxy\\n  -- Assume an edge $c$ between $x$ and $y$ is uncolored.\\n  by_contra!\\n  replace this : ⟨x, y, hxy⟩ ∈ void f := by\\n    simpa [void]\\n  set c : Seg := ⟨x, y, hxy⟩\\n  -- Then $c$ must be one of $s1, s2, s3$.\\n  simp [h.2.2.2] at this\\n  rw [def_base] at hxs\\n  have hxs1 := hxs.1 hx\\n  have hxs2 := hxs.1 hy\\n  simp at hxs1 hxs2\\n  -- This implies $c.ini = x$ is one of $\\{s1.ini, s2.ini, s3.ini\\}$.\\n  -- But $x$ was chosen from \"base\", which excludes these points. Contradiction.\\n  simp [Seg.ext_iff] at this\\n  tauto\\n\\n/-- A helper lemma for ordering three distinct points. -/\\nlemma split_or {xs : Finset (Fin 9)} {a b c : xs}\\n  (habc : a ≠ b ∧ a ≠ c ∧ b ≠ c) (hab : a < b) :\\n    c < a ∨ (a < c ∧ c < b) ∨ b < c := by\\n  replace habc : a.1 ≠ b ∧ a.1 ≠ c ∧ b.1 ≠ c := by\\n    simp only [ne_eq, Subtype.val_inj]\\n    exact habc\\n  replace hab : a.1 < b.1 := hab\\n  show c.1 < a ∨ (a.1 < c ∧ c.1 < b) ∨ b.1 < c\\n  by_cases hbc : b.1 < c\\n  · omega\\n  · replace hbc : c.1 < b := by omega\\n    · by_cases hac : a.1 < c\\n      · omega\\n      · replace hac : c.1 < a := by omega\\n        omega\\n\\n/-- If an option is not \"none\" and not \"some $y$\", it must be \"some $(1-y)$\". -/\\nlemma option_reduce {y : Fin 2} {x : Option (Fin 2)} (hx1 : x ≠ none) (hx2 : x ≠ y) :\\n    x = some (1 - y) := by\\n  match hx : x with\\n  | none => exact False.elim (hx1 rfl)\\n  | some 0 =>\\n    rw [Fin.eq_one_of_neq_zero y fun a ↦ hx2 (congrArg some a.symm)]; rfl\\n  | some 1 => match y with | 0 => rfl | 1 => exact False.elim (hx2 rfl)\\n\\n/-- Ramsey's Theorem $R(3,3)=6$: Any 2-coloring of the edges of a $K6$ contains a\\n    monochromatic triangle. -/\\nlemma ramsey {f : scheme} {xs : Finset (Fin 9)} (hxs1 : xs.card = 6)\\n  (hxs2 : ∀ x ∈ xs, ∀ y ∈ xs, (hxy : x < y) → f ⟨x, y, hxy⟩ ≠ none) :\\n    ∃ t : Tri, ¬ t.notMono f := by\\n  have xs_nonem : xs.Nonempty := by\\n    rw [← Finset.card_ne_zero, hxs1]\\n    decide\\n  -- Pick a vertex $p$ from the $K6$.\\n  set p := xs.max' xs_nonem with def_p\\n  -- Consider the other 5 vertices \"xs'\".\\n  set xs' := xs.erase p with def_xs'\\n  have xs'_card : xs'.card = 5 := by\\n    rw [def_xs', Finset.card_erase_of_mem, hxs1]\\n    exact Finset.max'_mem xs xs_nonem\\n  have i_lt_p {i : xs'} := xs.lt_max'_of_mem_erase_max' xs_nonem i.2\\n  -- The 5 edges from $p$ to \"xs'\" are all colored.\\n  have f_ip {i : xs'} := Option.ne_none_iff_exists'.1 <|\\n    hxs2 i ((Finset.erase_subset p xs) i.2) p\\n      (xs.max'_mem xs_nonem) i_lt_p\\n  -- By pigeonhole, at least 3 of these 5 edges have the same color.\\n  set f' : xs' → Fin 2 := fun i ↦\\n    Classical.choose f_ip\\n  have card1 : Fintype.card (Fin 2) = 2 := by decide\\n  have card2 : Fintype.card xs' = 5 := by\\n    rw [Fintype.card.eq_1, Finset.univ_eq_attach,\\n      Finset.card_attach, xs'_card]\\n  obtain ⟨y, hy⟩ := @Finset.exists_lt_card_fiber_of_mul_lt_card_of_maps_to xs' (Fin 2) _\\n    Finset.univ Finset.univ f' 2 (fun a _ ↦ Finset.mem_univ (f' a))\\n    <| by rw [Finset.univ_eq_attach, Finset.card_attach, xs'_card]; decide\\n  simp only [Finset.mem_univ, Finset.univ_eq_attach, true_and] at hy\\n  -- Let these 3 vertices be $a, b, c$, and the common color be $y$.\\n  obtain ⟨a, ha, b, hb, c, hc, habc⟩ := Finset.two_lt_card.1 hy\\n  simp only [Finset.mem_filter, Finset.mem_attach, true_and] at ha hb hc\\n  wlog hab : a < b\\n  · specialize @this f xs hxs1 hxs2 xs_nonem def_p def_xs' xs'_card _ _ card1 card2\\n      y hy b a c ⟨habc.1.symm, habc.2.2, habc.2.1⟩ hb ha hc\\n    refine this ?_\\n    simp at hab\\n    exact lt_of_le_of_ne hab habc.1.symm\\n  -- Edges (a,p), (b,p), (c,p) are all colored $y$.\\n  have h1 : f ⟨b, p, i_lt_p⟩ = f' b := Classical.choose_spec f_ip\\n  have h2 : f ⟨a, p, i_lt_p⟩ = f' a := Classical.choose_spec f_ip\\n  have h3 : f ⟨c, p, i_lt_p⟩ = f' c := Classical.choose_spec f_ip\\n  rw [ha] at h2\\n  rw [hb] at h1\\n  rw [hc] at h3\\n  have f_none {i j : {x // x ∈ xs'}} (hij : i < j) :=\\n    hxs2 i ((Finset.erase_subset p xs) i.2) j\\n      ((Finset.erase_subset p xs) j.2) hij\\n  -- Consider the triangle formed by $a, b, c$.\\n  obtain (hγ | hγ | hγ) := split_or habc hab\\n  · -- Case 1: $c < a < b$\\n    -- If any edge of triangle $(a,b,c)$ has color $y$...\\n    by_cases bottom :\\n      f ⟨a, b, hab⟩ = some y ∨\\n      f ⟨c, a, hγ⟩ = some y ∨\\n      f ⟨c, b, hγ.trans hab⟩ = some y\\n    · -- ...we have a monochromatic triangle of color $y$.\\n      casesm* _ ∨ _\\n      · use ⟨a, b, p, ⟨hab, i_lt_p⟩⟩\\n        simp [Tri.notMono, h1, h2, h3, bottom]\\n      · use ⟨c, a, p, ⟨hγ, i_lt_p⟩⟩\\n        simp [Tri.notMono, h1, h2, h3, bottom]\\n      · use ⟨c, b, p, ⟨hγ.trans hab, i_lt_p⟩⟩\\n        simp [Tri.notMono, h1, h2, h3, bottom]\\n    · -- Otherwise, all edges of triangle $(a,b,c)$ have the other color $1-y$.\\n      use ⟨c, a, b, ⟨hγ, hab⟩⟩\\n      push_neg at bottom\\n      replace h1 := option_reduce (f_none hab) bottom.1\\n      replace h2 := option_reduce (f_none hγ) bottom.2.1\\n      replace h3 := option_reduce (f_none (hγ.trans hab)) bottom.2.2\\n      simp [Tri.notMono, h1, h2, h3, bottom]\\n  · -- Case 2: $a < c < b$ (and other cases are similar)\\n    by_cases bottom :\\n      f ⟨a, c, hγ.1⟩ = some y ∨\\n      f ⟨c, b, hγ.2⟩ = some y ∨\\n      f ⟨a, b, hγ.1.trans hγ.2⟩ = some y\\n    · casesm* _ ∨ _\\n      · use ⟨a, c, p, ⟨hγ.1, i_lt_p⟩⟩\\n        simp [Tri.notMono, h1, h2, h3, bottom]\\n      · use ⟨c, b, p, ⟨hγ.2, i_lt_p⟩⟩\\n        simp [Tri.notMono, h1, h2, h3, bottom]\\n      · use ⟨a, b, p, ⟨hγ.1.trans hγ.2, i_lt_p⟩⟩\\n        simp [Tri.notMono, h1, h2, h3, bottom]\\n    · use ⟨a, c, b, hγ⟩\\n      push_neg at bottom\\n      replace h1 := option_reduce (f_none hγ.1) bottom.1\\n      replace h2 := option_reduce (f_none hγ.2) bottom.2.1\\n      replace h3 := option_reduce (f_none (hγ.1.trans hγ.2)) bottom.2.2\\n      simp [Tri.notMono, h1, h2, h3, bottom]\\n  · -- Case 3: $a < b < c$\\n    by_cases bottom :\\n      f ⟨a, b, hab⟩ = some y ∨\\n      f ⟨b, c, hγ⟩ = some y ∨\\n      f ⟨a, c, hab.trans hγ⟩ = some y\\n    · casesm* _ ∨ _\\n      · use ⟨a, b, p, ⟨hab, i_lt_p⟩⟩\\n        simp [Tri.notMono, h1, h2, h3, bottom]\\n      · use ⟨b, c, p, ⟨hγ, i_lt_p⟩⟩\\n        simp [Tri.notMono, h1, h2, h3, bottom]\\n      · use ⟨a, c, p, ⟨hab.trans hγ, i_lt_p⟩⟩\\n        simp [Tri.notMono, h1, h2, h3, bottom]\\n    · use ⟨a, b, c, ⟨hab, hγ⟩⟩\\n      push_neg at bottom\\n      replace h1 := option_reduce (f_none hab) bottom.1\\n      replace h2 := option_reduce (f_none hγ) bottom.2.1\\n      replace h3 := option_reduce (f_none (hab.trans hγ)) bottom.2.2\\n      simp [Tri.notMono, h1, h2, h3, bottom]\\n\\n/-- The minimal number of colored edges that guarantees a monochromatic triangle is 33. -/\\ntheorem IMO1992Q3 :\\n    Minimal {n : ℕ | ∀ f : scheme, (colored f).card = n → ¬ Scheme.noMono f} 33 := by\\n  apply minimal_iff_forall_lt.2\\n  constructor\\n  · -- Part 1: Show that $n=33$ is sufficient.\\n    change ∀ (f : scheme), (colored f).card = 33 → ¬Scheme.noMono f\\n    intro f hf\\n    -- If 33 edges are colored, then $36 - 33 = 3$ edges are uncolored.\\n    replace hf : (void f).card = 3 := by\\n      have := hf ▸ void_add_colored f\\n      omega\\n    -- This implies there is a $K6$ with all edges colored.\\n    obtain ⟨xs, hxs1, hxs2⟩ := select hf\\n    dsimp [Scheme.noMono]\\n    push_neg\\n    -- By Ramsey's theorem, this $K6$ must contain a monochromatic triangle.\\n    exact ramsey hxs1 hxs2\\n  · -- Part 2: Show that any $n < 33$ is not sufficient.\\n    intro y ylt hy\\n    change ∀ (f : scheme), (colored f).card = y → ¬Scheme.noMono f at hy\\n    replace ylt : y ≤ 32 := Nat.le_of_lt_succ ylt\\n    -- We use the counterexample \"n_32\" to show that for any $y \\leq 32$,\\n    -- there exists a coloring with no monochromatic triangle.\\n    exact IMO1992Q3_n_32_case_1 ylt hy\\n",
  "header": "import Mathlib\\n\\n",
  "formal_statement": "theorem IMO1992Q3 :\\n    Minimal {n : ℕ | ∀ f : scheme, (colored f).card = n → ¬ Scheme.noMono f} 33",
  "proof": "theorem IMO1992Q3 :\\n    Minimal {n : ℕ | ∀ f : scheme, (colored f).card = n → ¬ Scheme.noMono f} 33 := by\\n  apply minimal_iff_forall_lt.2\\n  constructor\\n  · -- Part 1: Show that $n=33$ is sufficient.\\n    change ∀ (f : scheme), (colored f).card = 33 → ¬Scheme.noMono f\\n    intro f hf\\n    -- If 33 edges are colored, then $36 - 33 = 3$ edges are uncolored.\\n    replace hf : (void f).card = 3 := by\\n      have := hf ▸ void_add_colored f\\n      omega\\n    -- This implies there is a $K6$ with all edges colored.\\n    obtain ⟨xs, hxs1, hxs2⟩ := select hf\\n    dsimp [Scheme.noMono]\\n    push_neg\\n    -- By Ramsey's theorem, this $K6$ must contain a monochromatic triangle.\\n    exact ramsey hxs1 hxs2\\n  · -- Part 2: Show that any $n < 33$ is not sufficient.\\n    intro y ylt hy\\n    change ∀ (f : scheme), (colored f).card = y → ¬Scheme.noMono f at hy\\n    replace ylt : y ≤ 32 := Nat.le_of_lt_succ ylt\\n    -- We use the counterexample \"n_32\" to show that for any $y \\leq 32$,\\n    -- there exists a coloring with no monochromatic triangle.\\n    exact IMO1992Q3_n_32_case_1 ylt hy\\n",
  "lean_version": {
    "mathlib_version": "4.17.0",
    "mathlib_commitid": "5269898d6a51d047931107c8d72d934d8d5d3753",
    "lean_version": "4.17.0"
  },
  "source": "IMO_1992_3",
  "category": "组合",
  "difficulty": "4"
}